# Testing Weave

```julia
#floudas_problems.jl
using DifferentialEquations
using ParameterizedFunctions
using DifferentialEquations
using Plots
gr()

desired_precision = Float64
#desired_precision = BigFloat

ode_fun_array = []
bounds_array = Vector{desired_precision}[]
rand_range_array = Vector{desired_precision}[]
phi_array = Vector{desired_precision}[]
ini_cond_array = Vector{desired_precision}[]
#x_t_array = Vector{desired_precision}[]
#delta_t_array = Vector{desired_precision}[]
t_array = Vector{desired_precision}[]
floudas_samples_array = Array{desired_precision}[]
floudas_samples_times_array = Array{desired_precision}[]

# ----- Problem 1 -----

function floudas_one(dz_dt, z, phi, t)
    r_1 = phi[1]*z[1]
    r_2 = phi[2]*z[2]

    dz_dt[1] = -r_1
    dz_dt[2] = r_1 - r_2
end

#==>
floudas_one_lambda = @ode_def begin
    r_1 = α*x
    r_2 = β*y

    dx = - r_1
    dy = r_1 - r_2
end α β
<=#

push!(ode_fun_array, floudas_one)
k1 = 5.0035
k2 = 1.
phi = [k1, k2]
push!(phi_array, phi)
push!(bounds_array, [0.,10.])
push!(rand_range_array, [0.,10.])
ini_cond = [1., 0.]
push!(ini_cond_array, ini_cond)
t = range(0, 1, length=10)
push!(t_array, t)
floudas_samples = [
                    1. 0.606 0.368 0.223 0.135 0.082 0.050 0.030 0.018 0.011 0.007;
                    0. 0.373 0.564 0.647 0.669 0.656 0.642 0.583 0.539 0.494 0.451
                    ]
push!(floudas_samples_array, floudas_samples)
floudas_samples_times = [
                        0. 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1
                        ]
push!(floudas_samples_times_array, floudas_samples_times)
p = scatter(transpose(floudas_samples_times), transpose(floudas_samples))
display(p)

# ----- Problem 2 -----

function floudas_two(dz_dt, z, phi, t)
    r_1 = phi[1]*z[1]
    r_2 = phi[2]*z[2]
    r_3 = phi[3]*z[2]
    r_4 = phi[4]*z[3]

    dz_dt[1] = - r_1 + r_2
    dz_dt[2] = r_1 - r_2 - r_3 + r_4
    dz_dt[3] = - r_4 + r_3
end

push!(ode_fun_array, floudas_two)
k1 = 4.
k2 = 2.
k3 = 40.013
k4 = 20.007
phi = [k1, k2, k3, k4]
push!(phi_array, phi)
push!(bounds_array, [0.,50.])
push!(rand_range_array, [0.,50.])
ini_cond = [1., 0., 0.]
push!(ini_cond_array, ini_cond)
t = range(0, 1, length=10)
push!(t_array, t)
floudas_samples = [
                    1. 0.8241 0.6852 0.5747 0.4867 0.4166 0.3608 0.3164 0.2810 0.2529 0.2304 0.2126 0.1984 0.1870 0.1870 0.1709 0.1651 0.1606 0.1570 0.1541 0.1518;
                    0. 0.0937 0.1345 0.1654 0.1899 0.2094 0.2249 0.2373 0.2472 0.2550 0.2613 0.2662 0.2702 0.2733 0.2759 0.2779 0.2794 0.2807 0.2817 0.2825 0.2832;
                    0. 0.0821 0.1802 0.2598 0.3233 0.3738 0.4141 0.4461 0.4717 0.4920 0.5082 0.5210 0.5313 0.5395 0.5460 0.5511 0.5553 0.5585 0.5612 0.5632 0.5649
                   ]
push!(floudas_samples_array, floudas_samples)
floudas_samples_times = [
                        0.0 0.05 0.1 0.15 0.2 0.25 0.3 0.35 0.4 0.45 0.5 0.55 0.6 0.65 0.7 0.75 0.8 0.85 0.9 0.95 1.0
                        ]
push!(floudas_samples_times_array, floudas_samples_times)
p = scatter(transpose(floudas_samples_times), transpose(floudas_samples))
display(p)

# ----- Problem 3 -----

function floudas_three(dz_dt, z, phi, t)
    r_1 = phi[1]*z[1]^2
    r_2 = phi[2]*z[2]
    r_3 = phi[3]*z[1]^2

    dz_dt[1] = - r_1 - r_3
    dz_dt[2] = r_1 - r_2
end

push!(ode_fun_array, floudas_three)
k1 = 12.214
k2 = 7.9798
k3 = 2.2216
phi = [k1, k2, k3]
push!(phi_array, phi)
push!(bounds_array, [0.,20.])
push!(rand_range_array, [0.,20.])
ini_cond = [1., 0.]
push!(ini_cond_array, ini_cond)
t = range(0, 1, length=10)
push!(t_array, t)
floudas_samples = [
                    1. 0.7307 0.5982 0.4678 0.4267 0.3436 0.3126 0.2808 0.2692 0.2210 0.2122 0.1903 0.1735 0.1615 0.1240 0.1190 0.1109 0.0890 0.0820 0.0745 0.0639;
                    0. 0.1954 0.2808 0.3175 0.3047 0.2991 0.2619 0.2391 0.2210 0.1898 0.1801 0.1503 0.1030 0.0964 0.0581 0.0471 0.0413 0.0367 0.0219 0.0124 0.0089
                    ]
push!(floudas_samples_array, floudas_samples)
floudas_samples_times = [
                        0. .025 .05 .075 .1 .125 .150 .175 .2 .225 .25 .3 .35 .4 .45 .5 .55 .65 .75 .85 .95
                        ]
push!(floudas_samples_times_array, floudas_samples_times)
p = scatter(transpose(floudas_samples_times), transpose(floudas_samples))
display(p)

# ----- Problem 4 -----

function floudas_four(dz_dt, z, phi, t)
    dz_dt[1] = phi[1]*(126.2 - z[1])*(91.9 - z[1])^2 - phi[2]*z[1]^2
end

push!(ode_fun_array, floudas_four)
k1 = 4.5704*10^(-6)
k2 = 2.7845*10^(-4)
phi = [k1, k2]
push!(phi_array, phi)
push!(bounds_array, [0,.1])
push!(rand_range_array, [0,.1])
ini_cond = [0.]
push!(ini_cond_array, ini_cond)
t = range(0, 40, length=10)
push!(t_array, t)
floudas_samples = [
                    0. 1.4 6.3 10.4 14.2 17.6 21.4 23.0 27.0 30.4 34.4 38.8 41.6 43.5 45.3
                    ]
push!(floudas_samples_array, floudas_samples)
floudas_samples_times = [
                        0. 1.0 2.0 3.0 4.0 5.0 6.0 7.0 9.0 11.0 14.0 19.0 24.0 29.0 39.0
                        ]
push!(floudas_samples_times_array, floudas_samples_times)
p = scatter(transpose(floudas_samples_times), transpose(floudas_samples))
display(p)

# ----- Problem 5 -----

function floudas_five(dz_dt, z, phi, t)
    dz_dt[1] = - (2*phi[1] - ((phi[1]*z[2])/((phi[2] + phi[5])*z[1] + z[2])) + phi[3] + phi[4])*z[1]
    dz_dt[2] = ((phi[1]*z[1])*(phi[2]*z[1] - z[2]))/((phi[2] + phi[5])*z[1] + z[2]) + phi[3]*z[1]
    dz_dt[3] = ((phi[1]*z[1])*(z[2] + phi[5]*z[1]))/((phi[2] + phi[5])*z[1] + z[2]) + phi[4]*z[1]
end

push!(ode_fun_array, floudas_five)
k1 = 5.2407
k2 = 1.2176
k3 = 0.
k4 = 0.
k5 = 0.
phi = [k1, k2, k3, k4, k5]
push!(phi_array, phi)
push!(bounds_array, [0.,100.])
push!(rand_range_array, [0.,100.])
ini_cond = [1., 0., 0.]
push!(ini_cond_array, ini_cond)
t = range(0, 1.2, length=10)
push!(t_array, t)
floudas_samples = [
                    1. 0.461 0.426 0.383 0.305 0.195 0.170 0.139 0.112  0.112 0.090 0.082 0.066 0.053 0.043 0.041 0.029;
                    0. 0.114 0.135 0.157 0.194 0.231 0.234 0.228 0.228  0.226 0.220 0.214 0.178 0.188 0.183 0.184 0.166;
                    0. 0.018 0.035 0.045 0.047 0.084 0.095 0.111 0.134 0.168 0.148 0.157 0.206 0.206 0.214 0.213 0.230
                    ]
push!(floudas_samples_array, floudas_samples)
floudas_samples_times = [
                        0. 0.050 0.065 0.080 0.123 0.233 0.273 0.354 0.397 0.418 0.502 0.553 0.681 0.750 0.916 0.937 1.122
                        ]
push!(floudas_samples_times_array, floudas_samples_times)
p = scatter(transpose(floudas_samples_times), transpose(floudas_samples))
display(p)

# ----- Problem 6 -----

function floudas_six(dz_dt, z, phi, t)
    dz_dt[1] = phi[1]*z[1]*(1-z[2])
    dz_dt[2] = phi[2]*z[2]*(z[1]-1)
end

push!(ode_fun_array, floudas_six)
k1 = 3.2434
k2 = 0.9209
phi = [k1, k2]
push!(phi_array, phi)
push!(bounds_array, [0.,10.])
push!(rand_range_array, [0.,10.])
ini_cond = [1.2, 1.1]
push!(ini_cond_array, ini_cond)
t = range(0, 10, length=10)
push!(t_array, t)
floudas_samples = [
                    1.2 0.7990 0.8731 1.2487 1.0362 0.7483 1.0024 1.2816 0.8944 0.7852 1.1527;
                    1.1 1.0758 0.8711 0.9393 1.1468 1.0027 0.8577 1.0274 1.1369 0.9325 0.9074
                    ]
push!(floudas_samples_array, floudas_samples)
floudas_samples_times = [
                        0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10.
                        ]
push!(floudas_samples_times_array, floudas_samples_times)
p = scatter(transpose(floudas_samples_times), transpose(floudas_samples))
display(p)
```

```julia
#objective_functions.jl
using LSODA
function adams_moulton_estimator(phi, data, time_array, ode_fun; plot_estimated=false)
    num_state_variables, num_samples = size(data)

    estimated = zeros(num_samples*num_state_variables)
    estimated = reshape(estimated, (num_state_variables, num_samples))
    estimated[:, 1] = data[:,1] #Initial conditions are stored at x_dot_num's first column

    for i in range(1, stop=num_samples-1)
        delta_t = time_array[i+1] - time_array[i]
        x_k_0 = data[:, i]
        x_k_1 = data[:, i+1]

        f_eval_0 = zeros(num_state_variables)
        ode_fun(f_eval_0, x_k_0, phi, 0)
        f_eval_1 = zeros(num_state_variables)
        ode_fun(f_eval_1, x_k_1, phi, 0)

        x_k_1_est = x_k_0 + (1/2)*delta_t*(f_eval_0+f_eval_1)
        estimated[:, i+1] = x_k_1_est
    end

    if plot_estimated
        p = scatter(transpose(estimated), title="Plot of $phi")
        display(p)
    end

    residuals = (data-estimated)
    return residuals
end


function data_shooting_estimator(phi, data, t, ode_fun; steps=1, plot_estimated=false)
    num_state_variables, num_samples = size(data)

    estimated = zeros(num_samples*num_state_variables)
    estimated = reshape(estimated, (num_state_variables, num_samples))
    estimated[:, 1] = data[:,1] #Initial conditions are stored at x_dot_num's first column

    for i in range(1, stop=num_samples-1)
        t_1 = t[i+1]
        t_0 = t[i]
        delta_t = t_1 - t_0

        x_k_0 = data[:, i]

        for i in 1:steps
            tspan = (t_0, t_1)
            oprob = ODEProblem(ode_fun, x_k_0, tspan, phi)
            osol  = solve(oprob, lsoda(), saveat=reduce(vcat, tspan))

            x_k_1 = x_k_0 + delta_t*(osol.u[end])
            x_k_0 = x_k_1
        end
        estimated[:, i+1] = x_k_1
    end

    if plot_estimated
        p = scatter(transpose(estimated), title="Plot of $phi")
        display(p)
    end

    residuals = (data-estimated)
    return residuals
end

function single_shooting_estimator(phi, data, t, ode_fun; plot_estimated=false)
    tspan = (t[1], t[end])
    ini_cond = data[:,1]
    oprob = ODEProblem(ode_fun, ini_cond, tspan, phi)
    osol  = solve(oprob, Tsit5(), saveat=reduce(vcat, t))
    estimated = reduce(hcat, osol.u)

    if plot_estimated
        p = scatter(transpose(estimated), title="Plot of $phi")
        display(p)
    end

    residuals = (data-estimated)
    return residuals
end

function single_shooting_estimator_residuals(phi, data, t, ode_fun; plot_estimated=false)
    tspan = (t[1], t[end])
    ini_cond = data[:,1]
    oprob = ODEProblem(ode_fun, ini_cond, tspan, phi)
    osol  = solve(oprob, Tsit5(), saveat=reduce(vcat, t))
    estimated = reduce(hcat, osol.u)

    if plot_estimated
        p = scatter(transpose(estimated), title="Plot of $phi")
        display(p)
    end
    residuals = (data-estimated)
    return reduce(vcat, residuals)
end

function soft_l1(z)
    return (2 * ((1 + z)^0.5 - 1))
end
```

## Continue testing
Defining function


#### Plotting

```julia
#countour_plot.jl
loss = soft_l1

function contour_3d_plots(x, y, z, phi; title="")
    cont = contour(x, y, z, fill=true, title=title)
    vline!(cont, [phi[1]])
    hline!(cont, [phi[2]])
    display(cont)

    three_dim = surface(x,y,z, cbar=true, title=title)
    display(three_dim)
end


function calc_z_plot(x, y, data, ode_fun, phi, t; fun="am")
    z = desired_precision[]
    if fun=="am"
        obj_fun = adams_moulton_estimator
    elseif fun=="cla"
        obj_fun = single_shooting_estimator
    end

    for i in range(1, stop=length(x))
        for j in range(1, stop=length(y))
            phi_eval = [x[i], y[j]]
            obj_eval = sum(loss.(abs2.(obj_fun(phi_eval, data, t, ode_fun))))
            push!(z, obj_eval)
        end
    end
    z = reshape(z, (length(y), length(x)))
    num_samples = length(data)
    contour_3d_plots(x, y, z, phi, title="$fun for num_samples=$num_samples")
end

for i in [1,4,6]
    println("\n----- Plots for problem $i -----\n")
    ode_fun = ode_fun_array[i]
    t = t_array[i]
    phi = phi_array[i]
    bounds = bounds_array[i]
    ini_cond = ini_cond_array[i]
    rand_range = rand_range_array[i]
    min_range = rand_range[1]
    max_range = rand_range[end]
    delta_t = desired_precision(.1)

    for num_samples in 3:20:23
        tspan = (t[1], t[end])
        oprob = ODEProblem(ode_fun, ini_cond, tspan, phi)
        #saveat_t = range(t[1], stop=t[end], length=num_samples)
        saveat_t = t[1]:((t[end]-t[1])/num_samples):t[end]
        osol  = solve(oprob, Tsit5(), saveat=saveat_t)
        plot(osol)
        println(osol.t)
        println(osol.u)
        data = reduce(hcat, osol.u)
        println(data)
        data_plot = scatter(saveat_t, transpose(data))
        display(data_plot)

        x = range(min_range, max_range, step=.05)
        y = range(min_range, max_range, step=.05)

        x_reduced = range(phi[1]-.05, phi[1]+.05, step=.001)
        y_reduced = range(phi[2]-.05, phi[2]+.05, step=.001)

        println("\n----- Adams-Moulton Estimator -----")
        calc_z_plot(x, y, data, ode_fun, phi, saveat_t, fun="am")
        calc_z_plot(x_reduced, y_reduced, data, ode_fun, phi, saveat_t, fun="am")

        println("\n----- Classic Estimator -----")
        calc_z_plot(x, y, data, ode_fun, phi, saveat_t, fun="cla")
        calc_z_plot(x_reduced, y_reduced, data, ode_fun, phi, saveat_t, fun="cla")
    end
end

x = range(1, 10, step=1)
y = range(1, 4, step=1)

z = []
for i in x
    for j in y
        push!(z, i*j)
    end
end
cont = contour(x, y, z, aspect_ratio=1, fill=true)
print(z)
z = reshape(z,(length(y),length(x)))
cont = contour(x, y, z, aspect_ratio=1, fill=true)
vline!(cont, [3])
hline!(cont, [3])
print(z)

z = float((1:4) * reshape(1:10, 1, :))
cont = contour(x, y, z, aspect_ratio=1, fill=true)
print(z)
```
